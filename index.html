<!DOCTYPE html>
<html>
  <head>
    <title>Video Processor</title>
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap"
      rel="stylesheet"
    />
    <style>
      * {
        font-family: 'Roboto', sans-serif;
        box-sizing: border-box;
      }
      body {
        margin: 0;
        background-color: #f5f5f5;
      }
      .tabs {
        display: flex;
        gap: 16px;
        padding: 16px;
        border-bottom: 1px solid #e0e0e0;
      }
      .tab {
        padding: 8px 16px;
        cursor: pointer;
        border-radius: 4px;
        background: #f5f5f5;
      }
      .tab.active {
        background: #2196f3;
        color: white;
      }
      .tab-content {
        display: block;
      }
      .video-card {
        background: white;
        border-radius: 8px;
        padding: 16px;
        margin: 8px;
        width: 25%;
        min-width: 300px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: box-shadow 0.3s ease, border 0.3s ease;
        border: 2px solid transparent;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .video-card.paired {
        width: 50%;
        min-width: 600px;
      }
      .video-card.selected {
        border: 2px solid #2196f3;
      }
      .video-card:hover {
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      }
      #cardsContainer,
      #pairedCardsContainer {
        display: flex;
        flex-wrap: wrap;
        justify-content: flex-start;
        gap: 16px;
        padding: 16px;
      }
      .controls {
        display: flex;
        gap: 16px;
        padding: 16px;
        align-items: center;
      }
      .pair-button {
        padding: 8px 16px;
        background: #2196f3;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: none;
      }
      .pair-button:disabled {
        background: #bdbdbd;
        cursor: not-allowed;
      }
      .video-container {
        display: flex;
        flex-direction: column;
        gap: 8px;
        margin-top: 8px;
      }
      .video-container.paired {
        flex-direction: row;
        gap: 16px;
      }
      .video-wrapper {
        width: 100%;
      }
      .video-wrapper.paired {
        width: 100%;
      }
      .video-wrapper.paired video {
        height: 300px;
        object-fit: cover;
      }
      .log-box {
        background-color: #f5f5f5;
        border-radius: 4px;
        padding: 8px;
        font-size: 14px;
        color: #757575;
        margin-top: 8px;
        min-height: 40px;
        display: flex;
        align-items: center;
        gap: 8px;
      }
      .log-box .material-icons {
        font-size: 16px;
      }
      .log-box.processing {
        background-color: #fff3e0;
        color: #e65100;
      }
      .log-box.complete {
        background-color: #e8f5e9;
        color: #2e7d32;
      }
      video {
        width: 100%;
        border-radius: 4px;
        background: #000;
      }
      .card-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        padding-bottom: 8px;
        border-bottom: 1px solid #e0e0e0;
        width: 100%;
      }
      .card-header h3 {
        margin: 0;
        font-size: 16px;
        font-weight: 500;
        color: #212121;
        max-width: 70%;
        overflow: hidden;
        text-overflow: ellipsis;
        white-space: nowrap;
      }
      .processing-info {
        font-size: 14px;
        color: #757575;
        display: flex;
        align-items: center;
        gap: 4px;
        flex-shrink: 0;
        padding: 4px 8px;
        border-radius: 16px;
        background-color: #f5f5f5;
        transition: all 0.3s ease;
        align-self: flex-end;
      }
      .processing-info .material-icons {
        font-size: 16px;
      }
      .processing-info.processing {
        background-color: #fff3e0;
        color: #e65100;
      }
      .processing-info.complete {
        background-color: #e8f5e9;
        color: #2e7d32;
      }
      #uploadBtn {
        position: fixed;
        bottom: 24px;
        right: 24px;
        width: 56px;
        height: 56px;
        border-radius: 50%;
        background-color: #2196f3;
        color: white;
        border: none;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        display: flex;
        align-items: center;
        justify-content: center;
        transition: background-color 0.3s ease, box-shadow 0.3s ease;
      }
      #uploadBtn:hover {
        background-color: #1976d2;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      }
      #uploadBtn .material-icons {
        font-size: 24px;
      }
      #fileInput {
        display: none;
      }
      .video-label {
        font-size: 14px;
        color: #757575;
        margin-bottom: 4px;
      }
      .processing {
        color: #ffa000;
      }
      .complete {
        color: #4caf50;
      }
      audio {
        width: 100%;
        max-width: 100%;
        margin-top: 8px;
      }
      .upload-button {
        margin-top: 16px;
        padding: 8px 16px;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        display: flex;
        align-items: center;
        gap: 8px;
        font-size: 14px;
        margin-left: auto;
      }

      /* Modal styles */
      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        justify-content: center;
        align-items: center;
      }

      .modal-content {
        background: white;
        padding: 20px;
        border-radius: 8px;
        max-width: 90%;
        max-height: 90%;
        position: relative;
      }

      .modal-close {
        position: absolute;
        top: 10px;
        right: 10px;
        background: none;
        border: none;
        color: #757575;
        cursor: pointer;
        font-size: 24px;
      }

      .modal-video-container {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }

      .modal-video {
        width: 100%;
        max-width: 800px;
        border-radius: 4px;
      }

      .modal-audio {
        width: 100%;
        max-width: 800px;
      }
    </style>
  </head>
  <body>
    <input type="file" id="fileInput" accept="video/*,.insv" multiple />
    <button id="uploadBtn" title="Upload Video">
      <span class="material-icons">add</span>
    </button>

    <!-- Modal -->
    <div id="previewModal" class="modal">
      <div class="modal-content">
        <button class="modal-close">&times;</button>
        <div class="modal-video-container">
          <video class="modal-video" controls></video>
          <audio class="modal-audio" controls></audio>
        </div>
      </div>
    </div>

    <div class="controls">
      <button id="pairButton" class="pair-button" disabled>
        Pair Selected Videos
      </button>
    </div>

    <div id="cardsContainer"></div>
    <div id="pairedCardsContainer"></div>

    <script>
      const ctx = new AudioContext();
      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');
      const cardsContainer = document.getElementById('cardsContainer');
      const pairedCardsContainer = document.getElementById(
        'pairedCardsContainer'
      );
      const pairButton = document.getElementById('pairButton');
      const tabs = document.querySelectorAll('.tab');
      let selectedCards = new Set();

      // Initialize view state
      function initializeView() {
        // Show all cards
        const allCards = cardsContainer.querySelectorAll('.video-card');
        allCards.forEach((card) => (card.style.display = 'block'));

        // Show all paired cards
        const pairedCards =
          pairedCardsContainer.querySelectorAll('.video-card');
        pairedCards.forEach((card) => {
          card.style.display = 'block';
          card.classList.add('paired');
        });
      }

      // Call initialization
      initializeView();

      // View switching
      tabs.forEach((tab) => {
        tab.addEventListener('click', () => {
          const view = tab.dataset.view;
          tabs.forEach((t) => t.classList.remove('active'));
          tab.classList.add('active');

          if (view === 'all') {
            // Show all cards
            const allCards = cardsContainer.querySelectorAll('.video-card');
            allCards.forEach((card) => (card.style.display = 'block'));

            // Show all paired cards
            const pairedCards =
              pairedCardsContainer.querySelectorAll('.video-card');
            pairedCards.forEach((card) => {
              card.style.display = 'block';
              card.classList.add('paired');
            });
          } else {
            // Hide all unpaired cards
            const allCards = cardsContainer.querySelectorAll('.video-card');
            allCards.forEach((card) => (card.style.display = 'none'));

            // Show all paired cards
            const pairedCards =
              pairedCardsContainer.querySelectorAll('.video-card');
            pairedCards.forEach((card) => {
              card.style.display = 'block';
              card.classList.add('paired');
            });
          }
        });
      });

      // Card selection
      function toggleCardSelection(card) {
        card.classList.toggle('selected');
        if (card.classList.contains('selected')) {
          selectedCards.add(card);
        } else {
          selectedCards.delete(card);
        }
        pairButton.disabled = selectedCards.size !== 2;
        pairButton.style.display = selectedCards.size === 2 ? 'block' : 'none';
      }

      async function decode(file) {
        const buffer = await file.arrayBuffer();
        return ctx.decodeAudioData(buffer);
      }

      function findOffset(signal1, signal2) {
        console.log('Finding offset using cross-correlation...');
        console.log(`Signal 1 length: ${signal1.length} samples`);
        console.log(`Signal 2 length: ${signal2.length} samples`);

        // Normalize signals
        const normalizeSignal = (signal) => {
          let max = 0;
          for (let i = 0; i < signal.length; i++) {
            max = Math.max(max, Math.abs(signal[i]));
          }
          return signal.map((x) => x / max);
        };

        const norm1 = normalizeSignal(signal1);
        const norm2 = normalizeSignal(signal2);

        // Use the shorter signal as the reference
        const reference = norm2;
        const search = norm1;

        // Maximum possible offset (in samples)
        const maxOffset = Math.floor(5 * ctx.sampleRate); // Search up to 5 seconds
        console.log(
          `Maximum search offset: ${maxOffset} samples (${
            maxOffset / ctx.sampleRate
          } seconds)`
        );

        let bestOffset = 0;
        let bestCorrelation = -Infinity;
        const correlations = [];

        // Perform cross-correlation
        for (let offset = 0; offset <= maxOffset; offset += 256) {
          // Step by 256 samples
          let correlation = 0;
          let count = 0;

          // Compare overlapping parts
          for (let i = 0; i < reference.length; i += 256) {
            if (i + offset < search.length) {
              correlation += search[i + offset] * reference[i];
              count++;
            }
          }

          correlation = count > 0 ? correlation / count : 0;
          correlations.push({ offset, correlation });

          if (correlation > bestCorrelation) {
            bestCorrelation = correlation;
            bestOffset = offset;
            console.log(
              `New best offset: ${offset} samples (${(
                offset / ctx.sampleRate
              ).toFixed(3)}s), correlation: ${correlation.toFixed(4)}`
            );
          }
        }

        // Log top 10 correlations
        correlations.sort((a, b) => b.correlation - a.correlation);
        console.log('\nTop 10 correlations:');
        correlations.slice(0, 10).forEach((c, i) => {
          console.log(
            `${i + 1}. Offset: ${c.offset} samples (${(
              c.offset / ctx.sampleRate
            ).toFixed(3)}s), Correlation: ${c.correlation.toFixed(4)}`
          );
        });

        return bestOffset;
      }

      async function audioAlign(checksum1, checksum2) {
        const f1 = getWindowUserFile(checksum1).data.audioBlob;
        const f2 = getWindowUserFile(checksum2).data.audioBlob;
        console.log('f1 and f2:');
        console.log(f1, f2);
        if (!f1 || !f2) return alert('Select both files!');

        // Find the paired card that contains these two videos
        const pairedCard = Array.from(
          pairedCardsContainer.querySelectorAll('.video-card')
        ).find((card) => {
          const videos = card.querySelectorAll('.video-wrapper');
          return (
            videos.length === 2 &&
            videos[0]
              .querySelector('.video-label')
              .textContent.includes(checksum1) &&
            videos[1]
              .querySelector('.video-label')
              .textContent.includes(checksum2)
          );
        });

        if (!pairedCard) {
          console.error('Could not find paired card');
          return;
        }

        const resultEl = pairedCard.querySelector('.log-box');
        const startTime = new Date();

        console.log('Starting audio comparison...');
        console.log(`File 1: ${f1.name}, size: ${f1.size} bytes`);
        console.log(`File 2: ${f2.name}, size: ${f2.size} bytes`);

        const [b1, b2] = await Promise.all([decode(f1), decode(f2)]);
        currentBuffers = [b1, b2];
        const hop = 1024; // Using larger hop for raw signal
        const fs = ctx.sampleRate;

        console.log(`Audio context sample rate: ${fs} Hz`);
        console.log(`File 1 duration: ${b1.duration.toFixed(3)} seconds`);
        console.log(`File 2 duration: ${b2.duration.toFixed(3)} seconds`);

        // Get the raw audio data
        const signal1 = b1.getChannelData(0);
        const signal2 = b2.getChannelData(0);

        // Find the offset using cross-correlation
        const offsetSamples = findOffset(signal1, signal2);
        const offsetSeconds = offsetSamples / fs;
        const endTime = new Date();
        const processingTime = ((endTime - startTime) / 1000).toFixed(1);

        resultEl.innerHTML = `
          <div class="log-box">
            <span>Estimated offset: ${offsetSeconds.toFixed(
              3
            )} seconds (Processed in ${processingTime}s)</span>
          </div>`;

        if (offsetSeconds > 0) {
          // If offset is positive, second video needs to be shifted
          updateWindowUserFile({ offset: 0 }, checksum1);
          updateWindowUserFile({ offset: offsetSeconds }, checksum2);
        } else {
          // If offset is negative, first video needs to be shifted
          updateWindowUserFile({ offset: Math.abs(offsetSeconds) }, checksum1);
          updateWindowUserFile({ offset: 0 }, checksum2);
        }
      }

      // Pair selected cards
      pairButton.addEventListener('click', async () => {
        if (selectedCards.size === 2) {
          if (!window.pairedCards) {
            window.pairedCards = [];
          }
          const selectedArray = Array.from(selectedCards);
          const checksum1 = selectedArray[0].id;
          const checksum2 = selectedArray[1].id;
          window.pairedCards.push([checksum1, checksum2]);
          console.log(window.pairedCards);
          const pairedCard = document.createElement('div');
          pairedCard.className = 'video-card paired';

          // Create a container for the paired videos
          const pairedContainer = document.createElement('div');
          pairedContainer.className = 'video-container paired';

          // Create result element for audio alignment
          const resultEl = document.createElement('div');
          resultEl.className = 'log-box';
          resultEl.style.marginTop = '16px';
          resultEl.innerHTML = `
            <span class="material-icons">hourglass_empty</span>
            <span>Calculating audio alignment...</span>`;

          // Move both selected cards into the paired container
          selectedCards.forEach((card) => {
            const videoContainer = card.querySelector('.video-container');
            const videoWrapper = videoContainer.querySelector('.video-wrapper');
            videoWrapper.classList.add('paired');

            // Create a container for the video and its preview button
            const videoAndButtonContainer = document.createElement('div');
            videoAndButtonContainer.style.cssText = `
              display: flex;
              flex-direction: column;
              gap: 8px;
              width: 100%;
            `;

            // Add preview button for this video
            const previewButton = document.createElement('button');
            previewButton.className = 'preview-button';
            previewButton.innerHTML = `
              <span class="material-icons">slow_motion_video</span>
              Preview Downsampled
            `;
            previewButton.style.cssText = `
              padding: 8px 16px;
              background: #ff9800;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              display: flex;
              align-items: center;
              gap: 8px;
              font-size: 14px;
              width: 100%;
            `;

            const checksum = card.id;
            previewButton.onclick = () => {
              const modal = document.getElementById('previewModal');
              const modalVideo = modal.querySelector('.modal-video');
              const modalAudio = modal.querySelector('.modal-audio');

              const file = getWindowUserFile(checksum);

              if (file && file.data.processedVideoBlob && file.data.audioBlob) {
                modalVideo.src = URL.createObjectURL(
                  file.data.processedVideoBlob
                );
                modalAudio.src = URL.createObjectURL(file.data.audioBlob);
                modal.style.display = 'flex';

                // Play both video and audio in sync
                modalVideo.playbackRate = 1 / 16;
                modalVideo.play();
                modalAudio.play();
              }
            };

            videoAndButtonContainer.appendChild(videoWrapper.cloneNode(true));
            videoAndButtonContainer.appendChild(previewButton);
            pairedContainer.appendChild(videoAndButtonContainer);
            card.remove();
          });

          pairedCard.appendChild(pairedContainer);
          pairedCard.appendChild(resultEl);
          pairedCardsContainer.insertBefore(
            pairedCard,
            pairedCardsContainer.firstChild
          );

          // Clear selection
          selectedCards.clear();
          pairButton.disabled = true;
          pairButton.style.display = 'none';
          await audioAlign(checksum1, checksum2);

          // Add upload button after alignment is complete
          const uploadButton = document.createElement('button');
          uploadButton.className = 'upload-button';
          uploadButton.innerHTML = `
            <span class="material-icons">cloud_upload</span>
            Upload
          `;
          uploadButton.style.cssText = `
            margin-top: 16px;
            padding: 8px 16px;
            background: #4caf50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            margin-left: auto;
          `;

          // Add play sync button
          const playSyncButton = document.createElement('button');
          playSyncButton.className = 'play-sync-button';
          playSyncButton.innerHTML = `
            <span class="material-icons">play_circle</span>
            Play Sync
          `;
          playSyncButton.style.cssText = `
            margin-top: 16px;
            padding: 8px 16px;
            background: #2196f3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            margin-right: 8px;
          `;

          playSyncButton.onclick = () => {
            const videos = pairedCard.querySelectorAll('.video-wrapper video');
            const video1 = videos[0];
            const video2 = videos[1];

            // Get the offset from whichever video has it
            const file1 = getWindowUserFile(checksum1);
            const file2 = getWindowUserFile(checksum2);
            const offset = file1.data.offset || file2.data.offset || 0;

            if (!video1.paused || !video2.paused) {
              video1.pause();
              video2.pause();
              return;
            }

            // Reset both videos
            video1.currentTime = 0;
            video2.currentTime = 0;

            // Play the video without offset first
            if (file1.data.offset) {
              video2.play();
              setTimeout(() => {
                video1.play();
              }, offset * 1000);
            } else {
              video1.play();
              setTimeout(() => {
                video2.play();
              }, offset * 1000);
            }
          };

          // Create a container for the buttons
          const buttonContainer = document.createElement('div');
          buttonContainer.style.cssText = `
            display: flex;
            justify-content: flex-end;
            margin-top: 16px;
          `;
          buttonContainer.appendChild(playSyncButton);
          buttonContainer.appendChild(uploadButton);
          pairedCard.appendChild(buttonContainer);

          // Close modal when clicking the close button
          document.querySelector('.modal-close').onclick = () => {
            const modal = document.getElementById('previewModal');
            modal.style.display = 'none';
            const modalVideo = modal.querySelector('.modal-video');
            const modalAudio = modal.querySelector('.modal-audio');
            modalVideo.pause();
            modalAudio.pause();
          };

          uploadButton.onclick = async () => {
            uploadButton.disabled = true;
            uploadButton.innerHTML = `
              <span class="material-icons">hourglass_empty</span>
              Uploading...
            `;

            try {
              const formData = new FormData();
              formData.append('video1', getWindowUserFile(checksum1).file);
              formData.append('video2', getWindowUserFile(checksum2).file);
              formData.append('offset', offsetSeconds.toString());

              const response = await fetch('/api/upload-paired-videos', {
                method: 'POST',
                body: formData,
              });

              if (!response.ok) {
                throw new Error('Upload failed');
              }

              uploadButton.innerHTML = `
                <span class="material-icons">check_circle</span>
                Upload Complete
              `;
              uploadButton.style.background = '#2e7d32';
            } catch (error) {
              uploadButton.innerHTML = `
                <span class="material-icons">error</span>
                Upload Failed
              `;
              uploadButton.style.background = '#d32f2f';
              console.error('Upload error:', error);
            }
          };
        }
      });

      uploadBtn.onclick = () => fileInput.click();

      function compressAudio(samples, sampleRate, options) {
        const { targetSampleRate, normalize } = options;

        // Downsample
        const downsampleRatio = sampleRate / targetSampleRate;
        const downsampledLength = Math.floor(samples.length / downsampleRatio);
        const downsampledData = new Float32Array(downsampledLength);

        for (let i = 0; i < downsampledLength; i++) {
          const originalIndex = Math.floor(i * downsampleRatio);
          downsampledData[i] = samples[originalIndex];
        }

        // Normalize if requested
        if (normalize) {
          let maxSample = 0;
          for (let i = 0; i < downsampledData.length; i++) {
            maxSample = Math.max(maxSample, Math.abs(downsampledData[i]));
          }

          if (maxSample > 0) {
            const normalizeScale = 0.99 / maxSample;
            for (let i = 0; i < downsampledData.length; i++) {
              downsampledData[i] *= normalizeScale;
            }
          }
        }

        // Simple dynamic range compression
        const threshold = 0.5;
        const ratio = 4;
        for (let i = 0; i < downsampledData.length; i++) {
          const sample = downsampledData[i];
          if (Math.abs(sample) > threshold) {
            const excess = Math.abs(sample) - threshold;
            const compressed = threshold + excess / ratio;
            downsampledData[i] = compressed * Math.sign(sample);
          }
        }

        return downsampledData;
      }

      function exportWAV(samples, sampleRate) {
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);

        function writeString(offset, str) {
          for (let i = 0; i < str.length; i++)
            view.setUint8(offset + i, str.charCodeAt(i));
        }

        writeString(0, 'RIFF');
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, samples.length * 2, true);

        let offset = 44;
        for (let i = 0; i < samples.length; i++, offset += 2) {
          let s = Math.max(-1, Math.min(1, samples[i]));
          view.setInt16(offset, s * 0x7fff, true);
        }

        return new Blob([view], { type: 'audio/wav' });
      }

      function newWindowUserFile(file, checksum) {
        if (!window.userFiles) {
          window.userFiles = [];
        }
        window.userFiles.push({ file: file, checksum: checksum });
      }

      function updateWindowUserFile(data, checksum) {
        const file = window.userFiles.find((f) => f.checksum === checksum);
        if (file) {
          file.data = {
            ...file.data,
            ...data,
          };
        }
      }

      function getWindowUserFile(checksum) {
        return window.userFiles.find((f) => f.checksum === checksum);
      }

      async function processAudio(file, card) {
        console.log('Processing audio...');
        const audioCtx = new (window.AudioContext ||
          window.webkitAudioContext)();
        const response = await fetch(URL.createObjectURL(file));
        const arrayBuffer = await response.arrayBuffer();
        const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
        // Process audio in chunks
        const chunkSize = 4096;
        const chunks = [];
        const totalChunks = Math.ceil(audioBuffer.length / chunkSize);

        for (let i = 0; i < totalChunks; i++) {
          const start = i * chunkSize;
          const end = Math.min(start + chunkSize, audioBuffer.length);
          const chunk = audioBuffer.getChannelData(0).slice(start, end);
          chunks.push(chunk);
        }

        // Combine chunks
        const flat = new Float32Array(chunks.reduce((a, b) => a + b.length, 0));
        let offset = 0;
        chunks.forEach((chunk) => {
          flat.set(chunk, offset);
          offset += chunk.length;
        });

        // Compress audio
        const compressionOptions = {
          targetSampleRate: audioCtx.sampleRate / 2,
          bitDepth: 16,
          normalize: true,
        };

        const compressedAudio = compressAudio(
          flat,
          audioCtx.sampleRate,
          compressionOptions
        );

        // Create WAV and preview
        const wavBlob = exportWAV(
          compressedAudio,
          compressionOptions.targetSampleRate
        );
        const wavUrl = URL.createObjectURL(wavBlob);
        const audio = document.createElement('audio');
        audio.controls = true;
        audio.src = wavUrl;
        audio.style.display = 'none';
        card.appendChild(audio);
        const id = card.id;
        updateWindowUserFile({ audioBlob: wavBlob }, id);
      }

      async function getChecksum(file) {
        return 'test' + file.name;
      }

      fileInput.onchange = async (e) => {
        const files = Array.from(e.target.files);
        if (!files.length) return;

        for (const file of files) {
          // Create a new card
          const checksum = await getChecksum(file);
          newWindowUserFile(file, checksum);
          const card = document.createElement('div');
          card.id = checksum;
          card.className = 'video-card';
          card.addEventListener('click', () => toggleCardSelection(card));

          // Create video containers
          const videoContainer = document.createElement('div');
          videoContainer.className = 'video-container';

          // Original video container
          const originalWrapper = document.createElement('div');
          originalWrapper.className = 'video-wrapper';
          originalWrapper.innerHTML = `<div class="video-label">${checksum}</div>`;
          const originalVideo = document.createElement('video');
          originalVideo.controls = true;
          originalVideo.src = URL.createObjectURL(file);
          originalWrapper.appendChild(originalVideo);

          // Processed video container
          const processedWrapper = document.createElement('div');
          processedWrapper.className = 'video-wrapper';
          processedWrapper.innerHTML = `<div class="video-label">${checksum} (16x)</div>`;
          processedWrapper.style.display = 'none';
          const processedVideo = document.createElement('video');
          processedVideo.controls = true;
          processedVideo.muted = true;
          processedWrapper.appendChild(processedVideo);

          videoContainer.appendChild(originalWrapper);
          videoContainer.appendChild(processedWrapper);
          card.appendChild(videoContainer);

          // Create log box
          const logBox = document.createElement('div');
          logBox.className = 'log-box processing';
          const startTime = new Date();
          logBox.innerHTML = `
            <span class="material-icons">hourglass_empty</span>
            <span>Processing video... (Started at ${startTime.toLocaleTimeString()})</span>`;
          card.appendChild(logBox);

          cardsContainer.appendChild(card);

          // Process the video
          const video = document.createElement('video');
          video.muted = true;
          video.src = URL.createObjectURL(file);

          await video.play();
          const stream = video.captureStream();
          // Remove audio tracks from the stream
          const videoOnlyStream = new MediaStream(stream.getVideoTracks());
          const recorder = new MediaRecorder(videoOnlyStream, {
            mimeType: 'video/webm',
            videoBitsPerSecond: 750000,
            video: {
              width: 640,
            },
          });
          const chunks = [];

          recorder.ondataavailable = (e) => chunks.push(e.data);
          recorder.onstop = () => {
            const endTime = new Date();
            const processingTime = ((endTime - startTime) / 1000).toFixed(1);
            const blob = new Blob(chunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            console.log('Blob size in MB:', blob.size / 1024 / 1024);
            processedVideo.src = url;
            updateWindowUserFile({ processedVideoBlob: blob }, checksum);
            processedVideo.playbackRate = 1 / 16;
            const logBox = card.querySelector('.log-box');
            logBox.className = 'log-box complete';
            logBox.innerHTML = `
              <span class="material-icons">check_circle</span>
              <span>Processing complete (${processingTime}s)</span>`;
          };

          video.playbackRate = 16;
          recorder.start();
          video.onended = () => recorder.stop();

          // Audio extraction section
          await processAudio(file, card);
        }

        // Clear the file input
        fileInput.value = '';
      };
    </script>
  </body>
</html>
